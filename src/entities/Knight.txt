
// Proximamente eso creo xdxdxD
export default class Knight extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'knight-idle');
        
        this.scene = scene;
        this.health = 80;
        this.maxHealth = 80;
        this.followDistance = 150; // M치s distante
        this.attackCooldown = 1200; // M치s r치pido
        this.lastAttack = 0;
        
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        this.setBounce(0.2);
        this.setCollideWorldBounds(true);
        this.setScale(1.2);
        this.setTint(0xFFD700); // Dorado
    }

    update(player) {
        if (!player) return;
        
        this.followPlayer(player);
        this.updateAnimation();
        this.autoAttackEnemies();
        this.defendPlayer(player); // NUEVO
    }

    followPlayer(player) {
        const distance = Phaser.Math.Distance.Between(
            this.x, this.y, player.x, player.y
        );

        // SEGUIR AL NINJA PERO M츼S INTELIGENTE
        if (distance > this.followDistance) {
            const speed = 130;
            
            if (player.x < this.x) {
                this.setVelocityX(-speed);
                this.setFlipX(true);
            } else if (player.x > this.x) {
                this.setVelocityX(speed);
                this.setFlipX(false);
            }

            // SALTAR OBST츼CULOS
            if (this.body.touching.down && Math.abs(player.y - this.y) > 50) {
                this.setVelocityY(-320);
            }
        } else {
            this.setVelocityX(0);
        }
    }

    // NUEVO - Defender al jugador
    defendPlayer(player) {
        // Si el jugador est치 siendo atacado, ir a ayudar
        const nearbyEnemies = this.scene.enemies.children.entries.filter(enemy => {
            const distanceToPlayer = Phaser.Math.Distance.Between(
                player.x, player.y, enemy.x, enemy.y
            );
            return distanceToPlayer < 120 && enemy.active;
        });

        if (nearbyEnemies.length > 0) {
            // IR HACIA EL ENEMIGO M츼S CERCANO AL JUGADOR
            const closestEnemy = nearbyEnemies.reduce((closest, enemy) => {
                const distA = Phaser.Math.Distance.Between(player.x, player.y, closest.x, closest.y);
                const distB = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
                return distB < distA ? enemy : closest;
            });

            const direction = closestEnemy.x > this.x ? 1 : -1;
            this.setVelocityX(direction * 160); // M치s r치pido cuando defiende
            this.setFlipX(direction < 0);
        }
    }

    autoAttackEnemies() {
        const currentTime = this.scene.time.now;
        if (currentTime - this.lastAttack < this.attackCooldown) return;

        const enemies = this.scene.enemies.children.entries;
        const nearbyEnemy = enemies.find(enemy => {
            const distance = Phaser.Math.Distance.Between(
                this.x, this.y, enemy.x, enemy.y
            );
            return distance < 90 && enemy.active; // Rango m치s amplio
        });

        if (nearbyEnemy) {
            this.attack();
            this.scene.damageEnemy(nearbyEnemy, 30); // M츼S DA칌O
            this.lastAttack = currentTime;
        }
    }

    attack() {
        if (this.scene.anims.exists('knight-attack')) {
            this.anims.play('knight-attack', true);
        }
        
        // EFECTO VISUAL M츼S 칄PICO
        this.setTint(0xffffff);
        this.scene.time.delayedCall(300, () => this.setTint(0xFFD700));
        
        console.log('丘덢잺 Knight DEFENDIENDO!');
    }

    updateAnimation() {
        if (this.body.velocity.x !== 0 && this.body.touching.down) {
            if (this.scene.anims.exists('knight-walk')) {
                this.anims.play('knight-walk', true);
            }
        } else if (this.body.touching.down) {
            if (this.scene.anims.exists('knight-idle')) {
                this.anims.play('knight-idle', true);
            }
        } else {
            if (this.scene.anims.exists('knight-jump')) {
                this.anims.play('knight-jump', true);
            }
        }
    }

    updateCompanion() {
        if (!this.companion || !this.player) return;

        const distance = Phaser.Math.Distance.Between(
            this.companion.x, this.companion.y, this.player.x, this.player.y
        );

        // SEGUIR AL NINJA
        if (distance > 120) {
            const direction = this.player.x > this.companion.x ? 1 : -1;
            this.companion.setVelocityX(direction * 140);
            this.companion.setFlipX(direction < 0);

            if (this.anims.exists('amigo-run')) {
                this.companion.anims.play('amigo-run', true);
            }

            // SALTAR SI EL NINJA EST츼 ARRIBA
            if (this.companion.body.touching.down && this.player.y < this.companion.y - 40) {
                this.companion.setVelocityY(-300);
            }
        } else {
            this.companion.setVelocityX(0);
            if (this.anims.exists('amigo-idle')) {
                this.companion.anims.play('amigo-idle', true);
            }
        }

        // ATAQUE AUTOM츼TICO DEL COMPA칌ERO
        this.companionAutoAttack();
    }

    // NUEVO M칄TODO - Ataque autom치tico del compa침ero
    companionAutoAttack() {
        if (!this.companion.lastAttack) {
            this.companion.lastAttack = 0;
        }

        const currentTime = this.time.now;
        if (currentTime - this.companion.lastAttack < 1500) return; // Cooldown de 1.5 segundos

        // BUSCAR ENEMIGOS CERCANOS
        const nearbyEnemy = this.enemies.children.entries.find(enemy => {
            const distance = Phaser.Math.Distance.Between(
                this.companion.x, this.companion.y, enemy.x, enemy.y
            );
            return distance < 100 && enemy.active;
        });

        if (nearbyEnemy) {
            // ATACAR
            this.companion.setTint(0xff6b6b);
            this.time.delayedCall(200, () => this.companion.clearTint());
            
            this.damageEnemy(nearbyEnemy, 20);
            this.companion.lastAttack = currentTime;
            
            console.log('游눤 Compa침ero atac칩 enemigo!');
        }
    }
}